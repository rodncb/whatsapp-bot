const { Client, LocalAuth } = require("whatsapp-web.js");
const qrcode = require("qrcode-terminal");
require("dotenv").config();

const audioHandler = require("./audio-handler");
const conversationMemory = require("./conversation-memory");

// Configura√ß√µes
const BOT_NAME = "Transcritor de √Åudio (Rodrigo)";

// Verifica se suporte a √°udio est√° habilitado
const AUDIO_ENABLED = audioHandler.isAudioEnabled();
if (AUDIO_ENABLED) {
  console.log("üé§ Suporte a √ÅUDIO HABILITADO (OpenAI Whisper)");
} else {
  console.log(
    "‚ö†Ô∏è  ERRO: OPENAI_API_KEY n√£o configurada! Este bot PRECISA de transcri√ß√£o."
  );
}

// Configura√ß√£o do cliente WhatsApp
const client = new Client({
  authStrategy: new LocalAuth({
    dataPath: "./.wwebjs_auth_teste", // Sess√£o separada do bot principal
  }),
  puppeteer: {
    headless: true,
    executablePath:
      "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    args: [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--disable-accelerated-2d-canvas",
      "--no-first-run",
      "--no-zygote",
      "--disable-gpu",
    ],
  },
});

// Eventos do WhatsApp
client.on("qr", (qr) => {
  console.log(
    "\nüîê ESCANEIE O QR CODE ABAIXO COM SEU WHATSAPP (+5524981058194):\n"
  );
  qrcode.generate(qr, { small: true });
  console.log(
    "\nüì± Abra o WhatsApp ‚Üí Aparelhos Conectados ‚Üí Conectar Aparelho\n"
  );
});

client.on("authenticated", () => {
  console.log("üîì Autentica√ß√£o realizada com sucesso!");
});

client.on("auth_failure", (msg) => {
  console.error("‚ùå Falha na autentica√ß√£o:", msg);
  console.log("üí° Tente deletar a pasta .wwebjs_auth_teste e reconectar");
});

client.on("disconnected", (reason) => {
  console.log("‚ö†Ô∏è  Bot desconectado:", reason);
  console.log("üîÑ Tentando reconectar...");
});

// Processa mensagens recebidas
client.on("message", async (msg) => {
  try {
    // ========================================
    // FILTRO PRINCIPAL: S√≥ responde mensagens NOVAS
    // ========================================

    // Ignora mensagens antigas (antes do bot conectar)
    if (!botReady) {
      return;
    }

    // Ignora mensagens que chegaram h√° mais de 30 segundos
    const messageTimestamp = msg.timestamp * 1000;
    const now = Date.now();
    const thirtySecondsAgo = now - 30000;

    if (messageTimestamp < thirtySecondsAgo) {
      console.log("üö´ Mensagem antiga ignorada (antes do bot conectar)");
      return;
    }

    // ========================================
    // FILTROS: O que IGNORAR
    // ========================================

    // 1. Ignora mensagens de GRUPOS
    if (msg.from.includes("@g.us")) {
      console.log("üö´ Mensagem de GRUPO ignorada");
      return;
    }

    // 2. Ignora STATUS
    if (msg.from === "status@broadcast") {
      return;
    }

    // 3. Ignora mensagens PR√ìPRIAS (suas)
    if (msg.fromMe) {
      console.log("üö´ Mensagem PR√ìPRIA ignorada (voc√™ mesmo)");
      return;
    }

    // 4. Ignora NOTIFICA√á√ïES autom√°ticas (boas-vindas, templates, etc)
    if (
      msg.type === "notification" ||
      msg.type === "notification_template" ||
      msg.type === "gp2" ||
      msg.isStatus
    ) {
      console.log("üö´ Notifica√ß√£o autom√°tica ignorada");
      return;
    }

    // 5. Ignora se N√ÉO for √ÅUDIO (este bot S√ì processa √°udios)
    if (msg.type !== "ptt" && msg.type !== "audio") {
      console.log(`üö´ Ignorado (n√£o √© √°udio): ${msg.type}`);
      return;
    }

    // ========================================
    // PROCESSA MENSAGEM (sempre processa, decide depois se responde)
    // ========================================

    const chatId = msg.from;
    const contact = await msg.getContact();
    const contactName = contact.pushname || contact.name || chatId;

    console.log("\n" + "=".repeat(50));
    console.log(`üì© Mensagem de: ${contactName}`);
    console.log(`üì± N√∫mero: ${chatId}`);
    console.log(`üìù Tipo: ${msg.type}`);

    // ========================================
    // VERIFICA SE VOC√ä J√Å PARTICIPOU DA CONVERSA HOJE
    // ========================================
    let youSentMessageToday = false;
    try {
      const chat = await msg.getChat();
      const messages = await chat.fetchMessages({ limit: 50 }); // √öltimas 50 mensagens

      // Pega data de hoje (apenas dia/m√™s/ano, sem hora)
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Procura se voc√™ mandou alguma mensagem hoje
      youSentMessageToday = messages.some((m) => {
        const messageDate = new Date(m.timestamp * 1000);
        messageDate.setHours(0, 0, 0, 0);

        return m.fromMe && messageDate.getTime() === today.getTime();
      });

      if (youSentMessageToday) {
        console.log(
          "ÔøΩ [MODO SILENCIOSO] Voc√™ j√° participou dessa conversa HOJE"
        );
        console.log("üìù Bot vai processar mas N√ÉO vai responder");
      }
    } catch (error) {
      console.log("‚ö†Ô∏è  Erro ao verificar hist√≥rico:", error.message);
      // Em caso de erro, assume que n√£o participou (melhor responder)
      youSentMessageToday = false;
    }

    // ========================================
    // SALVA MENSAGEM DO CLIENTE NO BD
    // ========================================
    const messageContent = msg.body || `[${msg.type}]`;
    conversationMemory.saveMessage(
      chatId,
      contactName,
      msg.type,
      messageContent,
      false, // n√£o √© do bot
      msg.timestamp
    );

    // ========================================
    // PROCESSA √ÅUDIO (se habilitado)
    // ========================================
    if (msg.type === "ptt" || msg.type === "audio") {
      console.log("üé§ √Åudio recebido");

      if (AUDIO_ENABLED) {
        // √ÅUDIO HABILITADO: Transcreve com OpenAI Whisper
        try {
          console.log("üîÑ Transcrevendo √°udio com OpenAI Whisper...");

          const chat = await msg.getChat();

          // S√≥ mostra "digitando" se for responder
          if (!youSentMessageToday) {
            await chat.sendStateTyping();
          }

          // Transcreve o √°udio
          const transcription = await audioHandler.processWhatsAppAudio(msg);

          console.log(`üí¨ Transcri√ß√£o: ${transcription}`);
          console.log(`üïê Hor√°rio: ${new Date().toLocaleString("pt-BR")}`);

          // Salva transcri√ß√£o no BD
          conversationMemory.saveMessage(
            chatId,
            contactName,
            "audio_transcribed",
            transcription,
            false, // √© do cliente (transcri√ß√£o)
            msg.timestamp
          );

          // Se voc√™ j√° participou da conversa hoje, N√ÉO responde
          if (youSentMessageToday) {
            console.log("‚úÖ Transcri√ß√£o salva no banco e logs");
            console.log("üö´ Bot N√ÉO respondeu (voc√™ j√° participou hoje)");
            console.log("=".repeat(50) + "\n");
            return;
          }

          // Simula tempo de digita√ß√£o
          const typingTime = Math.random() * 1000 + 1000;
          await new Promise((resolve) => setTimeout(resolve, typingTime));

          // Envia resposta autom√°tica para √ÅUDIO
          const replyAudio = getRandomReply(true);
          await msg.reply(replyAudio);

          // Salva resposta do bot no BD
          conversationMemory.saveMessage(
            chatId,
            "Assistente do Rodrigo",
            "text",
            replyAudio,
            true, // √© do bot
            Date.now() / 1000
          );

          console.log(`ü§ñ Resposta autom√°tica enviada!`);
          console.log("=".repeat(50) + "\n");
          return;
        } catch (audioError) {
          console.error("‚ùå Erro ao processar √°udio:", audioError.message);

          // S√≥ responde com erro se for conversa nova
          if (!youSentMessageToday) {
            await msg.reply(
              "Desculpe, tive um probleminha ao processar seu √°udio. Aguarde que o Rodrigo vai te responder em breve!"
            );
          }
          return;
        }
      } else {
        // √ÅUDIO DESABILITADO: Pede para enviar texto (s√≥ em conversas novas)
        console.log("‚ö†Ô∏è  √Åudio n√£o habilitado");

        if (!youSentMessageToday) {
          await msg.reply(getRandomReply(false));
          console.log(`ü§ñ Resposta autom√°tica enviada!`);
        } else {
          console.log("üö´ Bot N√ÉO respondeu (voc√™ j√° participou hoje)");
        }

        console.log("=".repeat(50) + "\n");
        return;
      }
    }

    // ========================================
    // PROCESSA TEXTO
    // ========================================

    if (msg.body) {
      console.log(`üí¨ Conte√∫do: ${msg.body}`);
    } else if (msg.type === "ptt" || msg.type === "audio") {
      console.log(`üí¨ Conte√∫do: [√ÅUDIO]`);
    } else if (msg.hasMedia) {
      console.log(`üí¨ Conte√∫do: [M√çDIA: ${msg.type}]`);
    }

    console.log(`üïê Hor√°rio: ${new Date().toLocaleString("pt-BR")}`);

    // Se voc√™ j√° participou da conversa hoje, N√ÉO responde
    if (youSentMessageToday) {
      console.log("‚úÖ Mensagem salva no banco e logs");
      console.log("üö´ Bot N√ÉO respondeu (voc√™ j√° participou hoje)");
      console.log("=".repeat(50) + "\n");
      return;
    }

    // Indicador de digita√ß√£o (parece mais humano)
    const chat = await msg.getChat();
    await chat.sendStateTyping();

    // Simula tempo de digita√ß√£o (1-2 segundos)
    const typingTime = Math.random() * 1000 + 1000;
    await new Promise((resolve) => setTimeout(resolve, typingTime));

    // Envia resposta autom√°tica para TEXTO
    const replyText = getRandomReply(false);
    await msg.reply(replyText);

    // Salva resposta do bot no BD
    conversationMemory.saveMessage(
      chatId,
      "Assistente do Rodrigo",
      "text",
      replyText,
      true, // √© do bot
      Date.now() / 1000
    );

    console.log(`ü§ñ Resposta autom√°tica enviada!`);
    console.log("=".repeat(50) + "\n");
  } catch (error) {
    console.error("‚ùå Erro ao processar mensagem:", error);

    try {
      await msg.reply(
        "Ops! Tive um probleminha aqui. Aguarde que o Rodrigo vai te responder em breve!"
      );
    } catch (replyError) {
      console.error("‚ùå Erro ao enviar mensagem de erro:", replyError);
    }
  }
});

// Tratamento de erros globais
process.on("unhandledRejection", (reason, promise) => {
  console.error("‚ùå Unhandled Rejection:", reason);
});

process.on("uncaughtException", (error) => {
  console.error("‚ùå Uncaught Exception:", error);
});

// Graceful shutdown
process.on("SIGINT", async () => {
  console.log("\n\n‚ö†Ô∏è  Encerrando bot de teste...");
  await client.destroy();
  console.log("‚úÖ Bot de teste encerrado com sucesso!");
  process.exit(0);
});

// Vari√°vel para controlar quando o bot est√° pronto
let botReady = false;

// Rastreia √∫ltimo timestamp de resposta do bot por chat (evita loop)
const lastBotReply = new Map(); // chatId -> timestamp

// Marca bot como pronto ap√≥s conectar
client.on("ready", () => {
  botReady = true;
  console.log("\n‚úÖ Bot de TESTE conectado com sucesso!");
  console.log(`ü§ñ ${BOT_NAME} est√° online!`);
  console.log("üìä Aguardando mensagens...\n");
  console.log("‚ö†Ô∏è  BOT DE TESTE: Responde todas mensagens automaticamente");
  console.log("üí¨ Respostas: Variam entre 3 op√ß√µes (texto/√°udio)");
  console.log("=".repeat(50));
});

// Inicia o bot
console.log("üöÄ Iniciando Bot de TESTE...");
console.log(`ü§ñ Nome: ${BOT_NAME}`);
console.log(`üì± N√∫mero: +5524981058194`);
console.log("\n‚ö†Ô∏è  MODO TESTE: Responde TODAS mensagens automaticamente");
console.log("üí¨ Respostas: Variam aleatoriamente (3 op√ß√µes)");
console.log("\n‚è≥ Aguardando QR Code...\n");

client.initialize();
